// Code generated by protoc-gen-go.
// source: users.proto
// DO NOT EDIT!

/*
Package users is a generated protocol buffer package.

It is generated from these files:
	users.proto

It has these top-level messages:
	TokenRequest
	Claims
	Context
	ClaimsResponse
	LoginRequest
	TokenResponse
	SendTokenRequest
	User
	UserRequest
	UsersResponse
	SimpleResponse
	ListUsersRequest
	Group
	GroupRequest
	GroupsResponse
	ListGroupsRequest
	Privilege
	PrivilegeRequest
	PrivilegesResponse
	ListPrivilegesRequest
	AssociateRequest
*/
package users

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TokenRequest struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *TokenRequest) Reset()                    { *m = TokenRequest{} }
func (m *TokenRequest) String() string            { return proto.CompactTextString(m) }
func (*TokenRequest) ProtoMessage()               {}
func (*TokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Claims struct {
	Sub        string          `protobuf:"bytes,1,opt,name=sub" json:"sub,omitempty"`
	Iss        string          `protobuf:"bytes,2,opt,name=iss" json:"iss,omitempty"`
	Iat        float64         `protobuf:"fixed64,3,opt,name=iat" json:"iat,omitempty"`
	Exp        float64         `protobuf:"fixed64,4,opt,name=exp" json:"exp,omitempty"`
	Name       string          `protobuf:"bytes,5,opt,name=name" json:"name,omitempty"`
	Email      string          `protobuf:"bytes,6,opt,name=email" json:"email,omitempty"`
	Privileges map[string]bool `protobuf:"bytes,7,rep,name=privileges" json:"privileges,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	// v1 auth holdover. remove once all systems are on usersv2 auth
	Context *Context `protobuf:"bytes,8,opt,name=context" json:"context,omitempty"`
}

func (m *Claims) Reset()                    { *m = Claims{} }
func (m *Claims) String() string            { return proto.CompactTextString(m) }
func (*Claims) ProtoMessage()               {}
func (*Claims) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Claims) GetPrivileges() map[string]bool {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *Claims) GetContext() *Context {
	if m != nil {
		return m.Context
	}
	return nil
}

// TODO(Cameron): remove after everybody is on users v2
type Context struct {
	Id         string          `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name       string          `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Email      string          `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
	Privileges map[string]bool `protobuf:"bytes,4,rep,name=privileges" json:"privileges,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *Context) Reset()                    { *m = Context{} }
func (m *Context) String() string            { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()               {}
func (*Context) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Context) GetPrivileges() map[string]bool {
	if m != nil {
		return m.Privileges
	}
	return nil
}

type ClaimsResponse struct {
	Claims *Claims `protobuf:"bytes,1,opt,name=claims" json:"claims,omitempty"`
}

func (m *ClaimsResponse) Reset()                    { *m = ClaimsResponse{} }
func (m *ClaimsResponse) String() string            { return proto.CompactTextString(m) }
func (*ClaimsResponse) ProtoMessage()               {}
func (*ClaimsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ClaimsResponse) GetClaims() *Claims {
	if m != nil {
		return m.Claims
	}
	return nil
}

type LoginRequest struct {
	Email    string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password" json:"password,omitempty"`
	// Token can be used instead of a password to generate an "impersonator" auth
	// token for the given email.
	Token string `protobuf:"bytes,3,opt,name=token" json:"token,omitempty"`
}

func (m *LoginRequest) Reset()                    { *m = LoginRequest{} }
func (*LoginRequest) ProtoMessage()               {}
func (*LoginRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type TokenResponse struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *TokenResponse) Reset()                    { *m = TokenResponse{} }
func (m *TokenResponse) String() string            { return proto.CompactTextString(m) }
func (*TokenResponse) ProtoMessage()               {}
func (*TokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type SendTokenRequest struct {
	Email string `protobuf:"bytes,1,opt,name=email" json:"email,omitempty"`
	Flow  string `protobuf:"bytes,2,opt,name=flow" json:"flow,omitempty"`
	// landing_url is the (trusted) page that the user will be directed to in
	// order to either confirm their email or update their password. This page
	// receives a token as a parameter, so we need to make sure it's not a page
	// outside of our control.
	LandingUrl string `protobuf:"bytes,3,opt,name=landing_url,json=landingUrl" json:"landing_url,omitempty"`
	// redirect_url is the page that the user should be redirected to after the
	// confirmation or password update has taken place. It does not have to be
	// trusted.
	RedirectUrl string `protobuf:"bytes,4,opt,name=redirect_url,json=redirectUrl" json:"redirect_url,omitempty"`
}

func (m *SendTokenRequest) Reset()                    { *m = SendTokenRequest{} }
func (m *SendTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*SendTokenRequest) ProtoMessage()               {}
func (*SendTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type User struct {
	Id             string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Email          string `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	Password       string `protobuf:"bytes,3,opt,name=password" json:"password,omitempty"`
	Name           string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Active         bool   `protobuf:"varint,5,opt,name=active" json:"active,omitempty"`
	EmailConfirmed bool   `protobuf:"varint,6,opt,name=email_confirmed,json=emailConfirmed" json:"email_confirmed,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type UserRequest struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user,omitempty"`
}

func (m *UserRequest) Reset()                    { *m = UserRequest{} }
func (m *UserRequest) String() string            { return proto.CompactTextString(m) }
func (*UserRequest) ProtoMessage()               {}
func (*UserRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *UserRequest) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type UsersResponse struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *UsersResponse) Reset()                    { *m = UsersResponse{} }
func (m *UsersResponse) String() string            { return proto.CompactTextString(m) }
func (*UsersResponse) ProtoMessage()               {}
func (*UsersResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UsersResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type SimpleResponse struct {
}

func (m *SimpleResponse) Reset()                    { *m = SimpleResponse{} }
func (m *SimpleResponse) String() string            { return proto.CompactTextString(m) }
func (*SimpleResponse) ProtoMessage()               {}
func (*SimpleResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type ListUsersRequest struct {
	Ids         []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	Email       string   `protobuf:"bytes,2,opt,name=email" json:"email,omitempty"`
	GroupId     string   `protobuf:"bytes,3,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	PrivilegeId string   `protobuf:"bytes,4,opt,name=privilege_id,json=privilegeId" json:"privilege_id,omitempty"`
	Limit       int64    `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
	Offset      int64    `protobuf:"varint,6,opt,name=offset" json:"offset,omitempty"`
}

func (m *ListUsersRequest) Reset()                    { *m = ListUsersRequest{} }
func (m *ListUsersRequest) String() string            { return proto.CompactTextString(m) }
func (*ListUsersRequest) ProtoMessage()               {}
func (*ListUsersRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type Group struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	Public      bool   `protobuf:"varint,4,opt,name=public" json:"public,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

type GroupRequest struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	// delete is only relevant for update RPCs, in which case it signals that the
	// group should be removed.
	Delete bool `protobuf:"varint,2,opt,name=delete" json:"delete,omitempty"`
}

func (m *GroupRequest) Reset()                    { *m = GroupRequest{} }
func (m *GroupRequest) String() string            { return proto.CompactTextString(m) }
func (*GroupRequest) ProtoMessage()               {}
func (*GroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GroupRequest) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type GroupsResponse struct {
	Groups []*Group `protobuf:"bytes,1,rep,name=groups" json:"groups,omitempty"`
}

func (m *GroupsResponse) Reset()                    { *m = GroupsResponse{} }
func (m *GroupsResponse) String() string            { return proto.CompactTextString(m) }
func (*GroupsResponse) ProtoMessage()               {}
func (*GroupsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *GroupsResponse) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type ListGroupsRequest struct {
	Ids         []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	UserId      string   `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	PrivilegeId string   `protobuf:"bytes,3,opt,name=privilege_id,json=privilegeId" json:"privilege_id,omitempty"`
	Public      bool     `protobuf:"varint,4,opt,name=public" json:"public,omitempty"`
	Limit       int64    `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
	Offset      int64    `protobuf:"varint,6,opt,name=offset" json:"offset,omitempty"`
}

func (m *ListGroupsRequest) Reset()                    { *m = ListGroupsRequest{} }
func (m *ListGroupsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListGroupsRequest) ProtoMessage()               {}
func (*ListGroupsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type Privilege struct {
	Id          string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// this is actually stored as part of the associate request, but is merged
	// into the privileges objects when returned from ListPrivileges by userId
	// or groupId.
	Denial bool `protobuf:"varint,3,opt,name=denial" json:"denial,omitempty"`
}

func (m *Privilege) Reset()                    { *m = Privilege{} }
func (m *Privilege) String() string            { return proto.CompactTextString(m) }
func (*Privilege) ProtoMessage()               {}
func (*Privilege) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type PrivilegeRequest struct {
	Privilege *Privilege `protobuf:"bytes,1,opt,name=privilege" json:"privilege,omitempty"`
}

func (m *PrivilegeRequest) Reset()                    { *m = PrivilegeRequest{} }
func (m *PrivilegeRequest) String() string            { return proto.CompactTextString(m) }
func (*PrivilegeRequest) ProtoMessage()               {}
func (*PrivilegeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *PrivilegeRequest) GetPrivilege() *Privilege {
	if m != nil {
		return m.Privilege
	}
	return nil
}

type PrivilegesResponse struct {
	Privileges []*Privilege `protobuf:"bytes,1,rep,name=privileges" json:"privileges,omitempty"`
}

func (m *PrivilegesResponse) Reset()                    { *m = PrivilegesResponse{} }
func (m *PrivilegesResponse) String() string            { return proto.CompactTextString(m) }
func (*PrivilegesResponse) ProtoMessage()               {}
func (*PrivilegesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *PrivilegesResponse) GetPrivileges() []*Privilege {
	if m != nil {
		return m.Privileges
	}
	return nil
}

type ListPrivilegesRequest struct {
	Ids     []string `protobuf:"bytes,1,rep,name=ids" json:"ids,omitempty"`
	UserId  string   `protobuf:"bytes,2,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	GroupId string   `protobuf:"bytes,3,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	Limit   int64    `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	Offset  int64    `protobuf:"varint,5,opt,name=offset" json:"offset,omitempty"`
}

func (m *ListPrivilegesRequest) Reset()                    { *m = ListPrivilegesRequest{} }
func (m *ListPrivilegesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPrivilegesRequest) ProtoMessage()               {}
func (*ListPrivilegesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

type AssociateRequest struct {
	UserId      string `protobuf:"bytes,1,opt,name=user_id,json=userId" json:"user_id,omitempty"`
	GroupId     string `protobuf:"bytes,2,opt,name=group_id,json=groupId" json:"group_id,omitempty"`
	PrivilegeId string `protobuf:"bytes,3,opt,name=privilege_id,json=privilegeId" json:"privilege_id,omitempty"`
	Denial      bool   `protobuf:"varint,4,opt,name=denial" json:"denial,omitempty"`
}

func (m *AssociateRequest) Reset()                    { *m = AssociateRequest{} }
func (m *AssociateRequest) String() string            { return proto.CompactTextString(m) }
func (*AssociateRequest) ProtoMessage()               {}
func (*AssociateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func init() {
	proto.RegisterType((*TokenRequest)(nil), "users.TokenRequest")
	proto.RegisterType((*Claims)(nil), "users.Claims")
	proto.RegisterType((*Context)(nil), "users.Context")
	proto.RegisterType((*ClaimsResponse)(nil), "users.ClaimsResponse")
	proto.RegisterType((*LoginRequest)(nil), "users.LoginRequest")
	proto.RegisterType((*TokenResponse)(nil), "users.TokenResponse")
	proto.RegisterType((*SendTokenRequest)(nil), "users.SendTokenRequest")
	proto.RegisterType((*User)(nil), "users.User")
	proto.RegisterType((*UserRequest)(nil), "users.UserRequest")
	proto.RegisterType((*UsersResponse)(nil), "users.UsersResponse")
	proto.RegisterType((*SimpleResponse)(nil), "users.SimpleResponse")
	proto.RegisterType((*ListUsersRequest)(nil), "users.ListUsersRequest")
	proto.RegisterType((*Group)(nil), "users.Group")
	proto.RegisterType((*GroupRequest)(nil), "users.GroupRequest")
	proto.RegisterType((*GroupsResponse)(nil), "users.GroupsResponse")
	proto.RegisterType((*ListGroupsRequest)(nil), "users.ListGroupsRequest")
	proto.RegisterType((*Privilege)(nil), "users.Privilege")
	proto.RegisterType((*PrivilegeRequest)(nil), "users.PrivilegeRequest")
	proto.RegisterType((*PrivilegesResponse)(nil), "users.PrivilegesResponse")
	proto.RegisterType((*ListPrivilegesRequest)(nil), "users.ListPrivilegesRequest")
	proto.RegisterType((*AssociateRequest)(nil), "users.AssociateRequest")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AuthCheck service

type AuthCheckClient interface {
	// Verifies the validity of an auth token.
	CheckToken(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*ClaimsResponse, error)
}

type authCheckClient struct {
	cc *grpc.ClientConn
}

func NewAuthCheckClient(cc *grpc.ClientConn) AuthCheckClient {
	return &authCheckClient{cc}
}

func (c *authCheckClient) CheckToken(ctx context.Context, in *TokenRequest, opts ...grpc.CallOption) (*ClaimsResponse, error) {
	out := new(ClaimsResponse)
	err := grpc.Invoke(ctx, "/users.AuthCheck/CheckToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthCheck service

type AuthCheckServer interface {
	// Verifies the validity of an auth token.
	CheckToken(context.Context, *TokenRequest) (*ClaimsResponse, error)
}

func RegisterAuthCheckServer(s *grpc.Server, srv AuthCheckServer) {
	s.RegisterService(&_AuthCheck_serviceDesc, srv)
}

func _AuthCheck_CheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthCheckServer).CheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.AuthCheck/CheckToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthCheckServer).CheckToken(ctx, req.(*TokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthCheck_serviceDesc = grpc.ServiceDesc{
	ServiceName: "users.AuthCheck",
	HandlerType: (*AuthCheckServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckToken",
			Handler:    _AuthCheck_CheckToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "users.proto",
}

// Client API for AuthGen service

type AuthGenClient interface {
	// Generates an auth token that can be used to authenticate to other APIs.
	GenerateToken(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenResponse, error)
	// Sends a link to either confirm an email address or reset a password.
	SendToken(ctx context.Context, in *SendTokenRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type authGenClient struct {
	cc *grpc.ClientConn
}

func NewAuthGenClient(cc *grpc.ClientConn) AuthGenClient {
	return &authGenClient{cc}
}

func (c *authGenClient) GenerateToken(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (*TokenResponse, error) {
	out := new(TokenResponse)
	err := grpc.Invoke(ctx, "/users.AuthGen/GenerateToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authGenClient) SendToken(ctx context.Context, in *SendTokenRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := grpc.Invoke(ctx, "/users.AuthGen/SendToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthGen service

type AuthGenServer interface {
	// Generates an auth token that can be used to authenticate to other APIs.
	GenerateToken(context.Context, *LoginRequest) (*TokenResponse, error)
	// Sends a link to either confirm an email address or reset a password.
	SendToken(context.Context, *SendTokenRequest) (*SimpleResponse, error)
}

func RegisterAuthGenServer(s *grpc.Server, srv AuthGenServer) {
	s.RegisterService(&_AuthGen_serviceDesc, srv)
}

func _AuthGen_GenerateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthGenServer).GenerateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.AuthGen/GenerateToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthGenServer).GenerateToken(ctx, req.(*LoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthGen_SendToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthGenServer).SendToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.AuthGen/SendToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthGenServer).SendToken(ctx, req.(*SendTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthGen_serviceDesc = grpc.ServiceDesc{
	ServiceName: "users.AuthGen",
	HandlerType: (*AuthGenServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GenerateToken",
			Handler:    _AuthGen_GenerateToken_Handler,
		},
		{
			MethodName: "SendToken",
			Handler:    _AuthGen_SendToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "users.proto",
}

// Client API for Users service

type UsersClient interface {
	// Createuser creates a new user object.
	CreateUser(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// UpdateUser updates an existing user object. Making a user's active field
	// false effectively deletes it.
	UpdateUser(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// ListUser queries existing user objects.
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*UsersResponse, error)
	// CreateGroup creates a new group object.
	CreateGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*GroupsResponse, error)
	// UpdateGroup updates an exisitng group object.
	UpdateGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*GroupsResponse, error)
	// ListGroups queries existing group objects.
	ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*GroupsResponse, error)
	// SavePrivilege creates/updates privilege objects.
	SavePrivilege(ctx context.Context, in *PrivilegeRequest, opts ...grpc.CallOption) (*PrivilegesResponse, error)
	// ListPrivileges queries existing privilege objects.
	ListPrivileges(ctx context.Context, in *ListPrivilegesRequest, opts ...grpc.CallOption) (*PrivilegesResponse, error)
	// CreateAssociation links two objects. The link can be:
	//  * User <-> Privilege (granting/denying a user a specific privilege)
	//  * User <-> Group (making user part of a group)
	//  * Group <-> Privilege (granting/denying a group a specific privilege)
	CreateAssociation(ctx context.Context, in *AssociateRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
	// RemoveAssociation unlinks two linked objects. E.g. removes a user from
	// a group, removes privileges from a group, etc.
	RemoveAssociation(ctx context.Context, in *AssociateRequest, opts ...grpc.CallOption) (*SimpleResponse, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) CreateUser(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := grpc.Invoke(ctx, "/users.Users/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateUser(ctx context.Context, in *UserRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := grpc.Invoke(ctx, "/users.Users/UpdateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*UsersResponse, error) {
	out := new(UsersResponse)
	err := grpc.Invoke(ctx, "/users.Users/ListUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*GroupsResponse, error) {
	out := new(GroupsResponse)
	err := grpc.Invoke(ctx, "/users.Users/CreateGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateGroup(ctx context.Context, in *GroupRequest, opts ...grpc.CallOption) (*GroupsResponse, error) {
	out := new(GroupsResponse)
	err := grpc.Invoke(ctx, "/users.Users/UpdateGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*GroupsResponse, error) {
	out := new(GroupsResponse)
	err := grpc.Invoke(ctx, "/users.Users/ListGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) SavePrivilege(ctx context.Context, in *PrivilegeRequest, opts ...grpc.CallOption) (*PrivilegesResponse, error) {
	out := new(PrivilegesResponse)
	err := grpc.Invoke(ctx, "/users.Users/SavePrivilege", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListPrivileges(ctx context.Context, in *ListPrivilegesRequest, opts ...grpc.CallOption) (*PrivilegesResponse, error) {
	out := new(PrivilegesResponse)
	err := grpc.Invoke(ctx, "/users.Users/ListPrivileges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateAssociation(ctx context.Context, in *AssociateRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := grpc.Invoke(ctx, "/users.Users/CreateAssociation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) RemoveAssociation(ctx context.Context, in *AssociateRequest, opts ...grpc.CallOption) (*SimpleResponse, error) {
	out := new(SimpleResponse)
	err := grpc.Invoke(ctx, "/users.Users/RemoveAssociation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Users service

type UsersServer interface {
	// Createuser creates a new user object.
	CreateUser(context.Context, *UserRequest) (*UsersResponse, error)
	// UpdateUser updates an existing user object. Making a user's active field
	// false effectively deletes it.
	UpdateUser(context.Context, *UserRequest) (*UsersResponse, error)
	// ListUser queries existing user objects.
	ListUsers(context.Context, *ListUsersRequest) (*UsersResponse, error)
	// CreateGroup creates a new group object.
	CreateGroup(context.Context, *GroupRequest) (*GroupsResponse, error)
	// UpdateGroup updates an exisitng group object.
	UpdateGroup(context.Context, *GroupRequest) (*GroupsResponse, error)
	// ListGroups queries existing group objects.
	ListGroups(context.Context, *ListGroupsRequest) (*GroupsResponse, error)
	// SavePrivilege creates/updates privilege objects.
	SavePrivilege(context.Context, *PrivilegeRequest) (*PrivilegesResponse, error)
	// ListPrivileges queries existing privilege objects.
	ListPrivileges(context.Context, *ListPrivilegesRequest) (*PrivilegesResponse, error)
	// CreateAssociation links two objects. The link can be:
	//  * User <-> Privilege (granting/denying a user a specific privilege)
	//  * User <-> Group (making user part of a group)
	//  * Group <-> Privilege (granting/denying a group a specific privilege)
	CreateAssociation(context.Context, *AssociateRequest) (*SimpleResponse, error)
	// RemoveAssociation unlinks two linked objects. E.g. removes a user from
	// a group, removes privileges from a group, etc.
	RemoveAssociation(context.Context, *AssociateRequest) (*SimpleResponse, error)
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateUser(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/UpdateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateUser(ctx, req.(*UserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateGroup(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/UpdateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateGroup(ctx, req.(*GroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ListGroups(ctx, req.(*ListGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_SavePrivilege_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrivilegeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).SavePrivilege(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/SavePrivilege",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).SavePrivilege(ctx, req.(*PrivilegeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ListPrivileges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPrivilegesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ListPrivileges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/ListPrivileges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ListPrivileges(ctx, req.(*ListPrivilegesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/CreateAssociation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateAssociation(ctx, req.(*AssociateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_RemoveAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AssociateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).RemoveAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/users.Users/RemoveAssociation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).RemoveAssociation(ctx, req.(*AssociateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "users.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _Users_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _Users_UpdateUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _Users_ListUsers_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _Users_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _Users_UpdateGroup_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _Users_ListGroups_Handler,
		},
		{
			MethodName: "SavePrivilege",
			Handler:    _Users_SavePrivilege_Handler,
		},
		{
			MethodName: "ListPrivileges",
			Handler:    _Users_ListPrivileges_Handler,
		},
		{
			MethodName: "CreateAssociation",
			Handler:    _Users_CreateAssociation_Handler,
		},
		{
			MethodName: "RemoveAssociation",
			Handler:    _Users_RemoveAssociation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "users.proto",
}

func init() { proto.RegisterFile("users.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1042 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x57, 0xcf, 0x8f, 0xdb, 0x54,
	0x10, 0xae, 0x13, 0xe7, 0xd7, 0x38, 0x49, 0xd3, 0xd7, 0x96, 0x75, 0x57, 0x40, 0x53, 0xab, 0x15,
	0x39, 0x45, 0x28, 0x48, 0x50, 0x95, 0x2e, 0xa8, 0xac, 0x96, 0x55, 0xa1, 0x07, 0xe4, 0x25, 0x5c,
	0x57, 0x5e, 0x7b, 0x76, 0xfb, 0xb4, 0x8e, 0x6d, 0xfc, 0x5e, 0xd2, 0xdd, 0x1b, 0x5c, 0xb8, 0x70,
	0xe7, 0xc6, 0x85, 0x03, 0xfc, 0x1f, 0xfc, 0x65, 0xe8, 0xfd, 0x72, 0x6c, 0x27, 0x59, 0xd1, 0xf6,
	0x96, 0x99, 0xf7, 0x66, 0xde, 0xcc, 0xf7, 0xcd, 0x7c, 0x56, 0xc0, 0x59, 0x32, 0xcc, 0xd9, 0x34,
	0xcb, 0x53, 0x9e, 0x92, 0x96, 0x34, 0xbc, 0xc7, 0xd0, 0xff, 0x31, 0xbd, 0xc4, 0xc4, 0xc7, 0x9f,
	0x97, 0xc8, 0x38, 0xb9, 0x07, 0x2d, 0x2e, 0x6c, 0xd7, 0x1a, 0x5b, 0x93, 0x9e, 0xaf, 0x0c, 0xef,
	0xaf, 0x06, 0xb4, 0x0f, 0xe3, 0x80, 0x2e, 0x18, 0x19, 0x41, 0x93, 0x2d, 0xcf, 0xf4, 0xb1, 0xf8,
	0x29, 0x3c, 0x94, 0x31, 0xb7, 0xa1, 0x3c, 0x94, 0xc9, 0x3b, 0x34, 0xe0, 0x6e, 0x73, 0x6c, 0x4d,
	0x2c, 0x5f, 0xfc, 0x14, 0x1e, 0xbc, 0xca, 0x5c, 0x5b, 0x79, 0xf0, 0x2a, 0x23, 0x04, 0xec, 0x24,
	0x58, 0xa0, 0xdb, 0x92, 0x61, 0xf2, 0xb7, 0x78, 0x1c, 0x17, 0x01, 0x8d, 0xdd, 0xb6, 0x7a, 0x5c,
	0x1a, 0xe4, 0x00, 0x20, 0xcb, 0xe9, 0x8a, 0xc6, 0x78, 0x81, 0xcc, 0xed, 0x8c, 0x9b, 0x13, 0x67,
	0xf6, 0xd1, 0x54, 0xf5, 0xa2, 0x8a, 0x9a, 0xfe, 0x50, 0x9c, 0x1f, 0x25, 0x3c, 0xbf, 0xf6, 0x4b,
	0x01, 0x64, 0x02, 0x9d, 0x30, 0x4d, 0x38, 0x5e, 0x71, 0xb7, 0x3b, 0xb6, 0x26, 0xce, 0x6c, 0x68,
	0x62, 0x95, 0xd7, 0x37, 0xc7, 0xfb, 0x07, 0x70, 0xbb, 0x96, 0x48, 0xd4, 0x7d, 0x89, 0xd7, 0xa6,
	0xdb, 0x4b, 0xbc, 0x16, 0x35, 0xae, 0x82, 0x78, 0x89, 0xb2, 0xdf, 0xae, 0xaf, 0x8c, 0x67, 0x8d,
	0xa7, 0x96, 0xf7, 0xaf, 0x05, 0x1d, 0x9d, 0x93, 0x0c, 0xa1, 0x41, 0x23, 0x1d, 0xd6, 0xa0, 0x51,
	0xd1, 0x6d, 0x63, 0x5b, 0xb7, 0xcd, 0x72, 0xb7, 0x5f, 0x55, 0xba, 0xb5, 0x65, 0xb7, 0x1f, 0x57,
	0x2b, 0xbe, 0xa9, 0xdd, 0xf7, 0x6d, 0xe2, 0x0b, 0x18, 0x2a, 0x4c, 0x7d, 0x64, 0x59, 0x9a, 0x30,
	0x24, 0x4f, 0xa0, 0x1d, 0x4a, 0x8f, 0x4c, 0xe0, 0xcc, 0x06, 0x15, 0xe8, 0x7d, 0x7d, 0xe8, 0xfd,
	0x04, 0xfd, 0x57, 0xe9, 0x05, 0x2d, 0x0f, 0x92, 0xea, 0xce, 0x2a, 0x77, 0xb7, 0x0f, 0xdd, 0x2c,
	0x60, 0xec, 0x4d, 0x9a, 0x47, 0x1a, 0x8b, 0xc2, 0x5e, 0x8f, 0x5e, 0xb3, 0x3c, 0x7a, 0x4f, 0x60,
	0xa0, 0x07, 0x54, 0xd7, 0xb3, 0x7d, 0x42, 0x7f, 0xb1, 0x60, 0x74, 0x82, 0x49, 0x54, 0x1f, 0xe6,
	0x2d, 0x35, 0x10, 0xb0, 0xcf, 0xe3, 0xf4, 0x8d, 0xe1, 0x42, 0xfc, 0x26, 0x0f, 0xc1, 0x89, 0x83,
	0x24, 0xa2, 0xc9, 0xc5, 0xe9, 0x32, 0x37, 0x8c, 0x80, 0x76, 0xcd, 0xf3, 0x98, 0x3c, 0x82, 0x7e,
	0x8e, 0x11, 0xcd, 0x31, 0xe4, 0xf2, 0x86, 0x2d, 0x6f, 0x38, 0xc6, 0x37, 0xcf, 0x63, 0xef, 0x4f,
	0x0b, 0xec, 0x39, 0xc3, 0x7c, 0x83, 0xfc, 0xa2, 0x8c, 0xc6, 0x2e, 0x28, 0x9a, 0x35, 0x28, 0xcc,
	0xb8, 0xd8, 0xa5, 0x71, 0xf9, 0x00, 0xda, 0x41, 0xc8, 0xe9, 0x4a, 0xad, 0x4c, 0xd7, 0xd7, 0x16,
	0xf9, 0x04, 0x6e, 0xcb, 0x84, 0xa7, 0x61, 0x9a, 0x9c, 0xd3, 0x7c, 0x81, 0x91, 0x5c, 0x9f, 0xae,
	0x3f, 0x94, 0xee, 0x43, 0xe3, 0xf5, 0xa6, 0xe0, 0x88, 0xf2, 0x0c, 0x38, 0x0f, 0xc1, 0x16, 0x44,
	0x6a, 0x56, 0x1d, 0xcd, 0xaa, 0xbc, 0x21, 0x0f, 0xbc, 0x19, 0x0c, 0x84, 0xb5, 0x9e, 0x84, 0x47,
	0xa0, 0x44, 0xc3, 0xb5, 0xe4, 0x54, 0x56, 0x42, 0xb4, 0x9c, 0x8c, 0x60, 0x78, 0x42, 0x17, 0x59,
	0x8c, 0x26, 0xc8, 0xfb, 0xdb, 0x82, 0xd1, 0x2b, 0xca, 0xb8, 0x4e, 0xa5, 0xde, 0x16, 0x02, 0x11,
	0xa9, 0x3c, 0x42, 0x32, 0x22, 0xb6, 0x03, 0xa3, 0x07, 0xd0, 0xbd, 0xc8, 0xd3, 0x65, 0x76, 0x4a,
	0x0d, 0x46, 0x1d, 0x69, 0xbf, 0x8c, 0x04, 0x21, 0xc5, 0xd4, 0x8b, 0x63, 0x4d, 0x48, 0xe1, 0x7b,
	0x29, 0x71, 0x8f, 0xe9, 0x82, 0x72, 0x09, 0x58, 0xd3, 0x57, 0x86, 0xc0, 0x31, 0x3d, 0x3f, 0x67,
	0xc8, 0x25, 0x4c, 0x4d, 0x5f, 0x5b, 0x1e, 0x42, 0xeb, 0x58, 0xe4, 0xfe, 0x5f, 0xbb, 0x3b, 0x06,
	0x27, 0x42, 0x16, 0xe6, 0x34, 0xe3, 0x34, 0x35, 0x13, 0x5b, 0x76, 0x89, 0x67, 0xb2, 0xe5, 0x59,
	0x4c, 0x43, 0x59, 0x59, 0xd7, 0xd7, 0x96, 0xf7, 0x1d, 0xf4, 0xe5, 0x33, 0x06, 0x0a, 0x0f, 0x5a,
	0xb2, 0x25, 0xcd, 0x43, 0x5f, 0x83, 0xaa, 0xee, 0xa8, 0x23, 0x91, 0x2b, 0xc2, 0x18, 0xb9, 0xd9,
	0x57, 0x6d, 0x79, 0x9f, 0xc3, 0x50, 0xde, 0x5b, 0x53, 0xf4, 0x18, 0xda, 0x32, 0xc4, 0x70, 0x54,
	0x4d, 0xa7, 0xcf, 0xbc, 0x7f, 0x2c, 0xb8, 0x23, 0x38, 0x31, 0xc1, 0xbb, 0x48, 0xd9, 0x83, 0x8e,
	0x08, 0x17, 0xf0, 0xaa, 0xe6, 0xdb, 0xc2, 0xdc, 0x02, 0x7e, 0x73, 0x13, 0xfc, 0x1d, 0xfd, 0xbf,
	0x25, 0x29, 0x73, 0xe8, 0x15, 0x6a, 0xb6, 0x41, 0x4c, 0x8d, 0x84, 0xc6, 0x56, 0x12, 0x22, 0x4c,
	0x68, 0xa0, 0x36, 0x5a, 0x02, 0x27, 0x2c, 0xef, 0x1b, 0x18, 0x15, 0x69, 0x4d, 0xfb, 0x53, 0xe8,
	0x15, 0xf5, 0x6b, 0x32, 0x46, 0x1a, 0xbd, 0xf5, 0xdd, 0xf5, 0x15, 0xef, 0x5b, 0x20, 0x6b, 0xa1,
	0x2d, 0x08, 0xf8, 0xb4, 0x22, 0xdf, 0x8a, 0x84, 0xcd, 0x34, 0xa5, 0x3b, 0xde, 0xef, 0x16, 0xdc,
	0x17, 0x64, 0x94, 0x93, 0xbd, 0x35, 0x21, 0x37, 0x2c, 0x4a, 0x01, 0xb8, 0xbd, 0x1d, 0xf0, 0x56,
	0x05, 0xf0, 0x5f, 0x2d, 0x18, 0xbd, 0x60, 0x2c, 0x0d, 0x69, 0xc0, 0x0b, 0x68, 0x4a, 0xcf, 0x5a,
	0x3b, 0x9f, 0x6d, 0xdc, 0xbc, 0x9f, 0xdb, 0x47, 0x44, 0xb3, 0x63, 0x97, 0xd9, 0x99, 0x1d, 0x43,
	0xef, 0xc5, 0x92, 0xbf, 0x3e, 0x7c, 0x8d, 0xe1, 0x25, 0x79, 0x06, 0x20, 0x7f, 0x48, 0x61, 0x27,
	0x77, 0x35, 0x94, 0x65, 0x99, 0xdf, 0xbf, 0x5f, 0xfd, 0x22, 0x19, 0xe5, 0xb9, 0x35, 0xfb, 0xcd,
	0x82, 0x8e, 0xc8, 0x74, 0x8c, 0x09, 0x79, 0x0e, 0x83, 0x63, 0x4c, 0x30, 0x0f, 0x38, 0x56, 0x53,
	0x95, 0xbf, 0x5a, 0xfb, 0xf7, 0xaa, 0xf9, 0x4d, 0x26, 0x72, 0x00, 0xbd, 0xe2, 0xeb, 0x42, 0xf6,
	0xf4, 0xa5, 0xfa, 0xf7, 0xa6, 0x28, 0xa4, 0x26, 0x81, 0xb7, 0x66, 0x7f, 0xb4, 0xa0, 0x25, 0x05,
	0x90, 0x3c, 0x05, 0x38, 0xcc, 0x31, 0xe0, 0x28, 0xbf, 0x14, 0xa4, 0x2c, 0xa1, 0xb5, 0x12, 0x2a,
	0xda, 0xeb, 0xdd, 0x12, 0x91, 0xf3, 0x2c, 0x7a, 0x97, 0xc8, 0xe7, 0xd0, 0x2b, 0x14, 0xb8, 0x28,
	0xbe, 0xae, 0xc9, 0x3b, 0xa3, 0xbf, 0x04, 0x47, 0x55, 0xac, 0xd4, 0xf1, 0x6e, 0x45, 0x51, 0x6a,
	0x8d, 0x57, 0xd5, 0x48, 0x05, 0xab, 0xa2, 0xdf, 0x25, 0xf8, 0x6b, 0x80, 0xb5, 0x4a, 0x11, 0xb7,
	0x54, 0x78, 0x45, 0xb8, 0x76, 0x27, 0x38, 0x82, 0xc1, 0x49, 0xb0, 0xc2, 0xb5, 0x82, 0xec, 0x6d,
	0x6c, 0xa2, 0x4e, 0xf1, 0xa0, 0x7e, 0x50, 0x4e, 0xf3, 0x3d, 0x0c, 0xab, 0x0b, 0x4a, 0x3e, 0x2c,
	0xd5, 0xb2, 0xb1, 0xb7, 0x37, 0x27, 0x3b, 0x82, 0x3b, 0x0a, 0x4e, 0xb3, 0x65, 0x42, 0xa7, 0x4c,
	0x5d, 0xf5, 0xcd, 0xdb, 0x39, 0x51, 0x22, 0x8d, 0x8f, 0x8b, 0x74, 0xf5, 0x7e, 0x69, 0xce, 0xda,
	0xf2, 0xcf, 0xc0, 0x67, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x27, 0x45, 0x59, 0x7a, 0x1b, 0x0c,
	0x00, 0x00,
}
